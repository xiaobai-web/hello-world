mysqld服务器程序构成
	连接层
		连接处理,身份验证,安全性等等
	SQL层
		处理底层数据之前的所有工作都是在这一层完成的,包括权限判断,sql解析,行计划优化,query cache的处理以及所有内置的函数(如日期、时间、数学运算、加密)等等。各个存储引擎提供的功能都集中在这一层,如存储过程,触发器,视图等.
	存储引擎层
		底层数据存取操作实现部分,由多种存储引擎共同组成。它们负责存储和获取所有存储在MySQL中的数据。

体系结构
	Connectors
		指的是不同语言中与SQL的交互。
	Management Serveices & Utilities
		系统管理和控制工具。
	Connection Pool  连接池
		管理缓冲用户连接,线程处理等需要缓存的需求。负责监听对MySQL Server的各种请求,接收连接请求,转发所有连接请求到线程管理模块。线程管理模块则负责管理维护这些连接线程。包括线程的创建,线程的cache等。
	SQL Interface  SQL接口
		接受用户的SQL命令,并且返回用户需要查询的结果。比如select from就是调用SQL Interface。
	Parser 解析器
		SQL命令传递到解析器的时候会被解析器验证和解析。将SQL语句进行语义和语法的分析,分解成数据结构,然后按照不同的操作类型进行分类,然后做出针对性的转发到后续步骤,以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误,那么就说明这个sql语句是不合理的
	Optimizer  查询优化器
		SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求的query(sql语句),根据客户端请求的query语句,和数据库中的一些统计信息,在一系列算法的基础上进行分析,得出一个最优的策略,告诉后面的程序如何取得这个query语句的结果.
	Cache和Buffer  查询缓存
        将客户端提交给MySQL的Select类query请求的返回结果集cache到内存中,与该query的一个hash值做一个对应。该Query所取数据的基表发生任何数据的变化之后,MySQL会自动使该query的Cache失效。
    存储引擎接口
        其底层数据存储引擎为插件式管理。存储引擎是底层物理结构的实现,每个存储引擎开发者都可以按照自己的意愿来进行开发。

存储引擎
    SQL层不依赖于存储引擎
    作用
        存储数据
        检索数据
        通过索引查找数据
    依赖引擎的功能
        存储介质
        事务功能
        锁定
        备份和恢复
        优化
        特殊功能：如全文搜索、引用完整性、空间数据处理等

数据库三范式
    第一范式：属性具有原子性,不可再分解,即不能表中有表
    第二范式：唯一性约束,每条记录有唯一标识,所有的非主键字段均需依赖于主键字段
    第三范式：冗余性约束,非主键字段间不能相互依赖
数据库设计原则
    避免冗余属性,冗余属性会带来数据不一致性
    一个表只存储它应该存储的信息,和此表无关的信息放到另一个表去存储,表之间尽量解耦
    一个字段中不要出现分隔符,或者在一个字段中存储多个信息
char 和 varchar 数据类型区别
    char:擅于存储经常改变的值,或者长度相对固定的值,查询和写入效率会更高。比如 type、ip 地址或 md5 之类的数据,不容易产生碎片
    varchar:善于存储值的长短不一的列,也是用的最多的一种类型,节省磁盘空间,保存可变长度字符串。这也是 innodb 官方推荐的类型

连接方式
    INNER JOIN(内连接,或等值连接):获取两个表中字段匹配关系的记录。
    LEFT JOIN(左连接):获取左表所有记录，即使右表没有对应匹配的记录。
    RIGHT JOIN(右连接)：与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录


SQL的四种隔离级别
    READ UNCOMMITED(未提交读)read uncommited
        在RERAD UNCOMMITED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也成为脏读（Dirty Read）。这个级别会导致很多问题，从性能上说READ UNCOMMITED 不会比其他的级别好太多，但缺乏其他级别的好多好处，除非有非常必要的理由，在实际的应用中一般很少使用READ UNCOMMITED.

    READ COMMITED (提交读)read commited
        大多数数据库系统的默认隔离级别都是READ COMMITED （但是MYSQL不是）。READ COMMITED 满足前面提到的隔离性的简单定义：一个事务开始时，只能看到已经提交的事务所做的修改。换句话说，一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复的（nonerepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。

    REPEATABLE READ (可重复读)repeatable read
        REPEATABLE READ (可重复读) 解决了脏读问题。该级别保证了在同一个事务中多次读取同样的记录的结果是一致的。但无法解决幻读问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行

    SERIALIZABLE(可串行化)serializable
        SERIALIZABLE是最高的隔离级别。它通过强制事务串行，避免了前面说的幻读问题。简单的来说，SERIALIZABLE会在读的每一行数据上 都加上锁，所以可能导致大量的超时和锁征用问题。

锁的类型
  行级锁  开销大
    共享锁,允许事务读一行数据
    排他锁,允许事务删除或者更新一行数据
  表级锁  开销小
    意向锁 为了实现多粒度锁
      意向共享锁,事务想要获得一个表中某几行的共享锁
      意向排他锁,事务想要获得一个表中某几行的排他锁
行锁 种类
    行锁:Record Lock 锁直接加在索引记录上面。
    间隙锁:Gap Lock 锁加在不存在的空闲空间，可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。
    Next-Key Lock:行锁与间隙锁组合起来用就叫做Next-Key Lock。InnoDB默认加锁方式是next-key 锁。


MVCC 多版本并发控制机制
    多版本的并发控制(MVCC)相对于传统的基于锁的并发控制主要特点是读不上锁.
    通过在每行记录后面保存两个隐藏的列来实现的,这两个列,分别保存了这个行的创建时间,一个保存的是行的删除时间。这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID.

存储引擎
    InnoDB
        支持事务,主要面向在线事务处理方面的应用。特点是行锁设计/支持外键,并支持非锁定读(默认读取操作不会产生锁).通过MVCC多版本并发控制获得高并发性,支持4种隔离级别,默认RR.采用newx-key策略避免幻读.
    MyISAM
        特点:不支持事务/表锁和全文索引,OLAP在线分析处理操作速度快.
    Memory
        将数据放于内存中,如果数据库重启或崩溃,表中的数据将消失。用于存放临时数据的临时表.

索引
    普通索引：最基本的索引,没有任何限制
    唯一索引：与"普通索引"类似,不同的就是：索引列的值必须唯一,但允许有空值
    主键索引：它是一种特殊的唯一索引,不允许有空值
    全文索引：针对较大的数据,生成全文索引很耗时好空间
    组合索引：为了更多的提高 MySQL 效率可建立组合索引,遵循"最左前缀"原则

聚族索引与非聚族索引的区别
    按物理存储分类：聚簇索引(clustered index)、非聚簇索引(non-clustered index)
    聚簇索引的叶子节点就是数据节点,而非聚簇索引的叶子节点仍然是索引节点,只不过有指向对应数据块的指针

分表数量级
    MySQL 单表容量在500万左右，性能处于最佳状态

日志文件
    错误日志    记录产生错误的sql语句
        show variables like 'log_error';
    慢查询日志   记录查询超过一定时间的sql语句(默认不开启)
        show variables like 'slow_query_log_file';
        long_query_time 时间阈值
        log_slow_queries 开启/关闭慢查询
        log_queries_not_using_indexes 开启后记录SQL语句有无使用索引
    查询日志
        show variables like '%general%';
        记录所有对数据库请求的信息,不论这些请求是否得到正确的执行
    二进制日志   记录了对数据库执行更改的所有操作,不包含查询操作.(默认不开启)
        show variables like 'log_bin';  查看二进制日志是否开启
        show binlog events in  'mysql-bin.000001';  查看日志详细信息
        show binary logs;   查看二进制日志

        log-bin     是否启动二进制日志,文件名默认为主机名,后缀名为日志序列号,所在路径为数据库所在路径。
        XXX.index      为二进制索引文件,储存过往生产的二进制日志序号
        max_binlog_size     单个二进制日志的最大值
        binlog_cache_size       设置事务操作的缓存大小来写入二进制日志
            可以使用SHOW GLOBAL STATUS 查看binlog_cache_use/binlog_cache_disk_use(使用缓存写入的次数/使用临时文件写入的次数)  状态判断缓存设置值是否合适
        sync_binlog     每写缓存多少次才写入二进制日志中,默认为0,建议设为ON
        binlog-do-db/binlog-ignore-db       需要写入/忽略写入哪些库的日志.默认为空
        log-slave-update       当数据库角色为slave时,不会从master取得的并执行的操作写入自己的二进制日志中。需配置该参数,才可写入
        binlog_format   记录二进制日志的格式
            STATEMENT 记录逻辑sql语句
            ROW 记录表的行更改情况(该记录方式会使文件增大)
            MIXED   默认采取STATEMENT格式进行记录,特定情况下使用ROW格式

数据库常用命令
    mysql>show variables like 'log%';   是否启用了日志
    mysql> show master status;  怎样知道当前的日志
    mysql> show master logs;    显示二进制日志的数目